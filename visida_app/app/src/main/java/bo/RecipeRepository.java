package bo;

import android.app.Application;
import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;

import androidx.arch.core.util.Function;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.lifecycle.Transformations;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;

import bo.db.AppDatabase;
import bo.db.dao.IngredientDao;
import bo.db.dao.RecipeDao;
import bo.db.entity.IngredientCapture;
import bo.db.entity.Recipe;

import static bo.AppConstants.ACTIVITY_LOG_TAG;

/**
 * Created by jnc985 on 29-Nov-17.
 * Repository for holding Household member data. This class holds ALL of the household member together.
 */

public class RecipeRepository {

    private static final String TAG = "RecipeRepository";
    private RecipeDao mRecipeDao;
    private IngredientDao mIngredientDao;
    private Context mContext;
    private LiveData<List<Recipe>> mAllRecipes;

    public RecipeRepository(Application application) {
        this.mRecipeDao = AppDatabase.getInstance(application).getRecipeDao();
        this.mIngredientDao = AppDatabase.getInstance(application).getIngredientDao();
        this.mContext = application;
        this.mAllRecipes = mRecipeDao.getAll();
    }


    /**
     * Adds a new recipe to the Databse. Since the PK of the recipe is autogenerated
     * this method also updates the recipe object with the generated Id.
     * @param recipe
     */
    public void addRecipe(Recipe recipe, TaskRunner.Callback<Long> callback){
        // Long generatedId = null;

        try {
            // generatedId = new AddRecipeAsync(mRecipeDao).execute(recipe).get();
            TaskRunner.executeAsync(new AddRecipeAsync(recipe), (generatedId) -> {
                recipe.setRecipeId(generatedId);
                //Update with the new id
                update(recipe);
                // Pass back the result asynchronously
                callback.onComplete(generatedId);
            });
            /*
            recipe.setRecipeId(generatedId);
            //Update with the new id
            update(recipe);
             */
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Recipe getRecipe(long recipeId) {
        Recipe recipe = null;
        try {
            recipe = new GetRecipeAsync(mRecipeDao).execute(recipeId).get();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return recipe;
    }

    public void update(Recipe recipe) {
        try {
            AppDatabase.executor.execute(() -> {
                mRecipeDao.update(recipe);
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void update(List<Recipe> recipes){
        for (Recipe r : recipes) {
            try {
                AppDatabase.executor.execute(() -> {
                    mRecipeDao.update(r);
                });
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public void update(IngredientCapture ingredient) {
        Log.i(ACTIVITY_LOG_TAG, TAG + ": Ingredient Capture Updated Image " + ingredient.getImageUrl() + " Audio " + ingredient.getAudioUrl() );
        try {
            AppDatabase.executor.execute(() -> {
                mIngredientDao.update(ingredient);
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void deleteIngredient(Context c, final IngredientCapture ingredient) {
        //Rename the image and audio files on disk
        String newImageName = "DELETED_" + ingredient.getImageName();
        String newAudioName = "DELETED_" + ingredient.getAudioName();
        Utilities.renameMediaFile(c, ingredient.getImageName(), newImageName);
        Utilities.renameMediaFile(c, ingredient.getAudioName(), newAudioName);
        //Delete the ingredient from the database
        Log.i(ACTIVITY_LOG_TAG, TAG + ": Ingredient deleted. Image " + ingredient.getImageUrl() + " Audio " + ingredient.getAudioUrl());
        try {
            AppDatabase.executor.execute(() -> {
                mIngredientDao.delete(ingredient);
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    public List<Recipe> getAllUnlocked() {
        try {
            return new GetAllUnlockedRecipesAsync(mRecipeDao).execute().get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }

    public LiveData<List<Recipe>> getAllRecipes(){
        return mAllRecipes;
    }

    public int recipeCount(){
        try {
            return new CountRecipesAsync(mRecipeDao).execute().get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        return -1;
    }


    public LiveData<List<Recipe>> getObservableUnsavedRecipes(){
        try {
            LiveData<List<Recipe>> recipes =  new GetAllObservableRecipesAsync(mRecipeDao).execute().get();
            recipes = Transformations.map(recipes, new Function<List<Recipe>, List<Recipe>>(){
                @Override
                public List<Recipe> apply(final List<Recipe> inputRecipes){
                    for (Recipe r : inputRecipes) {
                        try {
                            r.setIngredients(new GetIngredientsForRecipeAsync(mIngredientDao).execute(r.getRecipeId()).get());
                        } catch (InterruptedException | ExecutionException e) {
                            e.printStackTrace();
                        }
                    }
                    return inputRecipes;
                }
            });
            return recipes;
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }

    /*
    //https://proandroiddev.com/android-room-handling-relations-using-livedata-2d892e40bd53
    public LiveData<List<Recipe>> getObservableRecipes() {
        try {
            LiveData<List<Recipe>> recipes =  new GetAllObservableRecipesAsync(mRecipeDao).execute().get();
            recipes = Transformations.map(recipes, new Function<List<Recipe>, List<Recipe>>(){
               @Override
                public List<Recipe> apply(final List<Recipe> inputRecipes){
                   for (Recipe r : inputRecipes) {
                       try {
                           r.setIngredients(new GetIngredientsForRecipeAsync(mIngredientDao).execute(r.getRecipeId()).get());
                       } catch (InterruptedException | ExecutionException e) {
                           e.printStackTrace();
                       }
                   }
                   return inputRecipes;
               }
            });
            return recipes;
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
        return null;
    }
     */

    public void addIngredient(IngredientCapture ingredient){
        //Add the ingredient and get its generated id
        Long generatedId = null;
        try {
            generatedId = new AddIngredientCaptureAsync(mIngredientDao).execute(ingredient).get();
            ingredient.setIngredientId(generatedId);
            //Update with the new id
            new UpdateIngredientCaptureAsync(mIngredientDao).execute(ingredient);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void deleteRecipe(Recipe r) {
        try {
            AppDatabase.executor.execute(() -> {
                mRecipeDao.deleteRecipe(r);
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void deleteEmptyIngredients() {
        try {
            AppDatabase.executor.execute(() -> {
                mIngredientDao.deleteEmptyIngredients();
            });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    private static class CountRecipesAsync extends AsyncTask<Void, Void, Integer>{

        private RecipeDao mDao;
        CountRecipesAsync(RecipeDao dao){
            this.mDao = dao;
        }

        @Override
        protected Integer doInBackground(Void... voids) {
            return mDao.count();
        }
    }

    /*
    private static class GetAllObservableUnlockedRecipesAsync extends AsyncTask<Void, Void, LiveData<List<Recipe>>> {

        private RecipeDao mDao;
        GetAllObservableUnlockedRecipesAsync(RecipeDao dao){
            this.mDao = dao;
        }

        @Override
        protected LiveData<List<Recipe>> doInBackground(Void... voids) {
            return mDao.getAllObservableUnlocked();
        }
    }
     */

    private static class GetAllUnlockedRecipesAsync extends AsyncTask<Void, Void, List<Recipe>> {

        private RecipeDao mDao;
        GetAllUnlockedRecipesAsync(RecipeDao dao){
            this.mDao = dao;
        }

        @Override
        protected List<Recipe> doInBackground(Void... voids) {
            return mDao.getAllUnlocked();
        }
    }


    private class AddRecipeAsync implements Callable<Long> {
        private final Recipe input;

        public AddRecipeAsync(Recipe input) {
            this.input = input;
        }

        @Override
        public Long call() {
            // Some long running task
            return mRecipeDao.insert(input);
        }
    }

    private static class GetRecipeAsync extends AsyncTask<Long, Void, Recipe> {

        private RecipeDao mDao;
        GetRecipeAsync(RecipeDao dao){
            this.mDao = dao;
        }

        @Override
        protected Recipe doInBackground(Long... recipeId) {
            return mDao.get(recipeId[0]);
        }
    }

    private static class GetAllObservableRecipesAsync extends AsyncTask<Void, Void, LiveData<List<Recipe>>> {

        private RecipeDao mDao;
        GetAllObservableRecipesAsync(RecipeDao dao){
            this.mDao = dao;
        }

        @Override
        protected LiveData<List<Recipe>> doInBackground(Void... recipeId) {
            return mDao.getAllObservable();
        }
    }



    /**
     * Returns an observable list of ingredients for the given recipe Id
     * @param recipeId
     * @return
     */
    public LiveData<List<IngredientCapture>> getIngredients(long recipeId) {
        try {
            return new GetObservableIngredientsForRecipeAsync(mIngredientDao).execute(recipeId).get();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return new MutableLiveData<List<IngredientCapture>>();
    }

    private static class AddIngredientCaptureAsync extends AsyncTask<IngredientCapture, Void, Long> {

        private IngredientDao mDao;
        AddIngredientCaptureAsync(IngredientDao dao){
            this.mDao = dao;
        }

        @Override
        protected Long doInBackground(IngredientCapture... ingredients) {
            return mDao.insert(ingredients[0]);
        }
    }

    private static class UpdateIngredientCaptureAsync extends AsyncTask<IngredientCapture, Void, Void> {

        private IngredientDao mDao;
        UpdateIngredientCaptureAsync(IngredientDao dao){
            this.mDao = dao;
        }

        @Override
        protected Void doInBackground(IngredientCapture... ingredients) {
            mDao.update(ingredients[0]);
            return null;
        }
    }

    private static class GetObservableIngredientsForRecipeAsync extends AsyncTask<Long, Void, LiveData<List<IngredientCapture>>> {

        private IngredientDao mDao;
        GetObservableIngredientsForRecipeAsync(IngredientDao dao){
            this.mDao = dao;
        }

        @Override
        protected LiveData<List<IngredientCapture>> doInBackground(Long... recipeId) {
            return mDao.getObservableIngredientsForRecipe(recipeId[0]);
        }
    }

    private static class GetIngredientsForRecipeAsync extends AsyncTask<Long, Void, List<IngredientCapture>> {

        private IngredientDao mDao;
        GetIngredientsForRecipeAsync(IngredientDao dao){
            this.mDao = dao;
        }

        @Override
        protected List<IngredientCapture> doInBackground(Long... recipeId) {
            return mDao.getIngredientsForRecipe(recipeId[0]);
        }
    }
}
